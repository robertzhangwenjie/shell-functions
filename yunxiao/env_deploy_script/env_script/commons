#!/bin/bash

source /etc/rc.d/init.d/functions

# 执行语句并打印失败或成功
do_it() {
  local execute_cmd=$@
  local ret=$(eval $execute_cmd)
  local isSuccess=$?
  if [ $isSuccess -eq 0 ]; then
    action "$execute_cmd" /bin/true
    echo $ret
    return 0
  else
    action "$execute_cmd" /bin/false
    echo $ret
    return 1
  fi
}

# 杀死所有后台进程
killAllChildren() {
  echo "kill all children process..."
  for proc in $(jobs -p); do
    kill -9 $proc
  done
}

# 取消部署
cancel_deploy() {
  trap - INT TERM
  log_warning "canceling deploy service"
  kill_ws
}

checkPIDfile() {
  [[ ! -f "$PID_FILE" ]] && return 1
  procpid=$(<"$PID_FILE")
  [[ -z "$procpid" ]] && return 1
  if [ -e "/proc/$procpid" ]; then
    # 查看进程的执行命令，判断是否包含deploy.sh
    log_info "Running cmd: $(</proc/$procpid/cmdline)"
    return 0
  fi
  return 1
}

createPIDfile() {
  if [ -n "$PID_FIND_STR" ]; then
    mypid=$(ps ux | grep "${PID_FIND_STR}" | grep -v grep | awk '{print $2}')
    log_info "create pid_file: $PID_FILE"
    echo "$mypid" >$PID_FILE
  fi

}

log_info() {
  echo "$(date +"%Y-%m-%d %H:%M:%S") [INFO] $1"
}

log_warning() {
  echo -e "$(date +"%Y-%m-%d %H:%M:%S") \033[33m[WARNING]\033[0m" $1
}

log_error() {
  echo -e "$(date +"%Y-%m-%d %H:%M:%S") \033[31m[ERROR]\033[0m" $1
}

project_log_error_exit() {
  local error_message=$1

  if [ "$NEED_RESTORE" == "yes" ]; then
    log_info "部署失败"
    local restore_cmd=$(cat $RESTORE_FILE_PATH)
    [ -n $restore_cmd ] && log_info "开始执行上一次成功部署命令" && exec $restore_cmd
  fi

  [ -f "$HOME/deploy_project_env_${DEPLOY_ID}.log" ] && tail -n 100 $HOME/deploy_project_env_${DEPLOY_ID}.log
  echo "[ERROR] $error_message"
  rm -rf $PID_FILE
  exit 1
}

get_project_antx_properties() {
  if [ -z "$APP_NAME" ] || [ -z "$ENV_TYPE" ]; then
    project_log_error_exit "appNme and envType cannot be empty"
  fi

  log_info "Get antx properties : \"$GET_ANTX_PROPERTIES_URL?appName=$APP_NAME&antxType=$ENV_TYPE&crid=${CRID}\""
  rm -rf $HOME/antx.properties.$APP_NAME.$ENV_TYPE
  curl -o antx.properties.${APP_NAME}.${ENV_TYPE} -sSL "${GET_ANTX_PROPERTIES_URL}?appName=${APP_NAME}&antxType=${ENV_TYPE}&crid=${CRID}&from=xx"

  # 将当前环境的配置项设置为环境变量
  if [[ -s antx.properties.${APP_NAME}.${ENV_TYPE} ]]; then
    cat $HOME/antx.properties.$APP_NAME.$ENV_TYPE | while read line; do
      origin_key=$(echo $line | awk -F"=" '{print $1}')
      key=$(eval echo $origin_key)
      origin_value=$(echo $line | awk -F"=" '{print $2}')
      value=$(eval echo $origin_value)

      log_info "Set env variable:$key=$value"
      echo "export $key=$value" >>env.properties.$APP_NAME.$ENV_TYPE
      source env.properties.$APP_NAME.$ENV_TYPE
    done
  fi

}

# 清理当前用户运行的所有服务
kill_ws() {

  log_info "清理java服务以及PIDfile"
  checkPIDfile
  if [ $? -eq 0 ]; then
    local mypid=$(<$PID_FILE)
    log_info "kill -9 $mypid"
    do_it kill -9 $mypid
    rm "$PID_FILE"
  fi

  # 清理docker
  log_info "清理docker服务"
  sudo docker ps -a | awk 'NR != 1{print $(NF)}' | grep ${APP_NAME}-${ENV_TYPE}
  [ $? -eq 0 ] && do_it sudo docker rm -f ${APP_NAME}-${CRID}

  # 清理nginx
  log_info ""
  ls ${NGINX_CONFIG_DIR} | grep -w ${NGINX_CONF}
  [ $? -eq 0 ] && rm -f ${NGINX_CONFIG_DIR}/${NGINX_CONF}
  do_it sudo ${NGINX_CMD} -s reload
}

rm_except() {
  cd ${WORK_DIR}
  local all_files=$(ls)
  local except_files="$@"
  log_info "rm except files:$except_files"
  for file in $all_files; do
    local del=true
    for except_file in $except_files; do
      if [[ "$file" == "$except_file" ]]; then
        del=false
        break
      fi
    done
    [ $del = true ] && rm -rf $file
  done
}

# 清理环境,删除相关文件
clean_work_dir() {
  log_info "starting clear $WORK_DIR"
  # 杀掉上一次的部署
  if [ "$NEED_RESTORE" == "yes" ]; then
    rm_except "env_script env_script.zip $RESTORE_FILE"
  else
    rm_except "env_script env_script.zip"
  fi
}

clean_env() {
  log_info "开始清理环境"
  kill_ws
  clean_work_dir
}

# 检查部署状态
check_deploy_status() {
  checkPIDfile
  [ $? -eq 0 ] && project_log_error_exit "deploy failed for pidFile is empty"
  check_url 
} 

# 检查url是否可以访问
check_url() {
  log_info "starting check if can access with url: ${CHECK_URL}"

  if [ "$CHECK_URL"x == ""x ]; then
    log_info "无检查URL"
    return
  fi

  check_url=$CHECK_URL
  log_info "Starting check $APP_NAME with url: $check_url"
  local count=0
  local max_check_num=3

  while true; do
    ((count++))
    [[ $count -gt ${max_check_num} ]] && project_log_error_exit "Failed to check app with url: $check_url.\n
      Please go to the server to check the application's startup log."

    log_info "try $count times"
    local resp_code=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 -m 5 $check_url)
    [[ "$resp_code" == "200" ]] && break
    sleep 3
  done

  log_info "$check_url return 200"
}

# 部署war包
deploy_war() {

  local deploy_package=$1
  log_info "获取${TOMCAT7_VERSION}.zip"
  wget -P ${HOEM} -nv ${TOMCAT_DOWNLOAD_URL} ||
    cp ${TOMCAT_PATH}/${TOMCAT_VERSION}.zip ${HOME}
  unzip ${HOME}/${TOMCAT_VERSION}.zip

  log_info "Starting deploy $deploy_package"
  #PORT1/2/3是tomcat的其他端口
  MINUS=$(expr 8080 - $PORT)
  PORT1=$(expr 8443 - $MINUS)
  PORT2=$(expr 8009 - $MINUS + 20)
  PORT3=$(expr 8005 - $MINUS + 20)

  # 修改tomcat配置文件
  log_info "修改tomcat配置：PORT:${PORT}"
  cd $TOMCAT_HOME/conf
  sed -i "s/8080/$PORT/g" server.xml
  sed -i "s/8443/$PORT1/g" server.xml
  sed -i "s/8009/$PORT2/g" server.xml
  sed -i "s/8005/$PORT3/g" server.xml

  # 设置查找该pid的命令
  PID_FIND_STR="${TOMCAT_VERSION}"
  log_info "启动tomcat"
  cd $TOMCAT_HOME/bin

  chmod 755 *.sh
  sh startup.sh
  sleep 3
  return
}

# 部署jar包
deploy_jar() {
  local deploy_package=$1
  log_info "Starting deploy $deploy_package"
  PID_FIND_STR="java -jar $deploy_package"

  log_info "nohup java -jar $deploy_package 2>&1 &"
  nohup java -jar $deploy_package 2>&1 &
  sleep 3
}

# 部署.tar.gz包
deploy_tgz() {
  local deploy_package=$1
  log_info "Starting deploy ${deploy_package}"

  # 生成nginx配置文件，根据ENV_TYPE.APP_NAME.com作为域名 NGINX_HTML_DIR/APP_NAME作为root
  log_info "generate nginx config"
  eval "cat <<EOF 
  $(<$NGINX_TEMPLATE_PATH) 
  EOF "
  >${NGINX_CONFIG_DIR}/$NGINX_CONF

  # 部署目录
  # deploy_dir=${NGINX_HOME}/html/${APP_NAME}/
  # log_info "清理部署目录: ${deploy_dir}"
  # [ -d ${deploy_dir} ] && rm -rf ${deploy_dir}
  # tar -xvf ${deploy_package} -C  ${deploy_dir} > /dev/null 2>&1

  log_info "解压部署包${deploy_package}到${HOME}"
  tar -xvf ${deploy_package} -C ${HOME}

  # 重启nginx server
  log_info "Restart nginx"
  eval "sudo ${NGINX_CMD} -s reload"
}

# 部署docker容器
deploy_docker() {
  local imageName=$1
  log_info "Starting deploy $imageName"
  # 部署容器时，需要获取容器中的端口，进行映射，此项可以在配置项中配置
  # 默认为暴漏的端口
  CONTAINER_PORT=${container_port:-${PORT}}
  log_info "PORT:${PORT},CONTAINER_PORT:${CONTAINER_PORT}"
  # 判断是否正在部署
  sudo docker ps -a | awk 'NR != 1{print $(NF)}' | grep ${APP_NAME}-${ENV_TYPE}
  [ $? -eq 0 ] && sudo docker rm -f ${APP_NAME}-${ENV_TYPE}
  # 部署的容器名称为应用名-项目名
  sudo docker run -d --name ${APP_NAME}-${ENV_TYPE} -p ${PORT}:${CONTAINER_PORT} $imageName
}

# 开始部署
start_env() {

  war_Suffix=".war"
  jar_Suffix=".jar"
  tar_gz_Suffix=".tar.gz"
  zip_Suffix=".zip"

  # 获取构建包名
  deploy_package=$(echo ${TAR_ADDRESS##*/})

  # 如果部署包为docker镜像(判断是否包含":"")，则使用root权限部署
  if [[ $deploy_package =~ .+:.+ ]]; then
    imageName=$TAR_ADDRESS
    deploy_docker $imageName
  fi

  # 下载部署包,-nv非详细输出
  log_info "开始下载 $TAR_ADDRESS"
  wget -nv http://package.switch.aliyun.com:8088/$TAR_ADDRESS

  # 下载失败则退出
  [ $? -eq 1 ] && project_log_error_exit "下载失败"

  # 根据包名匹配对应的部署脚本
  if [[ ${deploy_package} =~ $war_Suffix ]]; then
    deploy_war ${deploy_package}

  elif [[ ${deploy_package} =~ $jar_Suffix ]]; then
    deploy_jar ${deploy_package}

  elif [[ ${deploy_package} =~ $tar_gz_Suffix ]]; then
    deploy_tgz ${deploy_package}
  else
    project_log_error_exit "没有此构建包的部署方式"
  fi

  log_info "Deploy ${deploy_package} completed"
}
