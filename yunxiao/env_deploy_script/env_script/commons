#!/bin/bash

source /etc/rc.d/init.d/functions
source /etc/profile

# 执行语句并打印失败或成功
do_it() {
  local execute_cmd ret
  execute_cmd="$@"
  ret=$($execute_cmd)
  local isSuccess=$?
  if [ $isSuccess -eq 0 ]; then
    action "$execute_cmd" true
    echo $ret
    return 0
  else
    action "$execute_cmd" false
    echo $ret
    return 1
  fi
}

# 杀死所有后台进程
killAllChildren() {
  echo "kill all children process..."
  for proc in $(jobs -p); do
    kill -9 $proc
  done
}

# 取消部署
cancel_deploy() {
  trap - INT TERM HUP
  log_warning "canceling deploy service"
  kill_ws
}

# 检查PIDFILE
checkPIDfile() {
  if [ ! -e "$PID_FILE" ]; then
    log_warning "该应用程序pid文件不存在"
    return 1
  fi

  procpid=$(<"$PID_FILE")

  if [ -e "/proc/$procpid" ]; then
    # 查看进程的执行命令，判断是否包含deploy.sh
    log_info "应用程序正在运行: $(</proc/$procpid/cmdline)"
    return 0
  fi
  return 1
}

# 创建PIDFILE
createPIDfile() {
  if [ -n "$PID_FIND_STR" ]; then
    mypid=$(ps ux | grep "${PID_FIND_STR}" | grep -v grep | awk '{print $2}')
    if [ $? -eq 0 -o -n "$mypid" ]; then
      echo "$mypid" >$PID_FILE
      log_info "创建 pid_file: $PID_FILE, PID:$mypid"
      return 0
    else
      project_log_error_exit "deploy failed for cannot find pid with ${PID_FIND_STR}"
    fi
  fi

}

# 打印INFO级别日志
log_info() {
  echo -e "$(date +"%Y-%m-%d %H:%M:%S") [INFO] $1"
}

# 打印WARNING级别日志
log_warning() {
  echo -e "$(date +"%Y-%m-%d %H:%M:%S") \033[33m[WARNING]\033[0m" $1
}

# 打印错误日志
log_error() {
  echo -e "$(date +"%Y-%m-%d %H:%M:%S") \033[31m[ERROR]\033[0m" $1
}

# 退出程序
project_log_error_exit() {
  local error_message=$1

  if [ "$NEED_RESTORE" == "yes" ]; then
    log_info "部署失败"
    local restore_cmd=$(cat $RESTORE_FILE_PATH)
    [ -n $restore_cmd ] && log_info "开始执行上一次成功部署命令" && exec $restore_cmd
  fi

  [ -f "$HOME/deploy_project_env_${DEPLOY_ID}.log" ] && tail -n 100 $HOME/deploy_project_env_${DEPLOY_ID}.log
  log_error " $error_message"
  rm -rf $PID_FILE
  exit 1
}

# 获取配置项
get_project_antx_properties() {
  if [ -z "$APP_NAME" ] || [ -z "$ENV_TYPE" ]; then
    project_log_error_exit "appNme and envType cannot be empty"
  fi

  rm -rf $HOME/antx.properties.$APP_NAME.$ENV_TYPE
  log_info "获取应用配置项: \"$GET_ANTX_PROPERTIES_URL?appName=$APP_NAME&antxType=$ENV_TYPE&crid=${CRID}&from=xx\""
  curl -o antx.properties.${APP_NAME}.${ENV_TYPE} -sSL "${GET_ANTX_PROPERTIES_URL}?appName=${APP_NAME}&antxType=${ENV_TYPE}&crid=${CRID}&from=xx"

  # 将当前环境的配置项设置为环境变量
  if [[ -s antx.properties.${APP_NAME}.${ENV_TYPE} ]]; then
    log_info "配置项内容：$(<antx.properties.${APP_NAME}.${ENV_TYPE})"
    echo '#!/bin/bash' >$ENV_PROPERTIES_FILE
    cat $HOME/antx.properties.$APP_NAME.$ENV_TYPE | while read line; do
      origin_key=$(echo $line | awk -F"=" '{print $1}')
      key=$(eval echo $origin_key)
      origin_value=$(echo $line | awk -F"=" '{print $2}')
      value=$(eval echo $origin_value)

      log_info "获取配置项:$key=$value"
      echo "$key=$value" >>$ENV_PROPERTIES_FILE
    done
  elif [ -f antx.properties.${APP_NAME}.${ENV_TYPE} ]; then
    log_info "应用配置项为空"
  elif [ ! -e antx.properties.${APP_NAME}.${ENV_TYPE} ]; then
    log_error "应用配置获取失败,请检查配置项API是否设置正确"
  fi
}

# 清理当前用户运行的所有服务
kill_ws() {

  # 清理java服务
  checkPIDfile
  if [ $? -eq 0 ]; then
    local mypid=$(<$PID_FILE)
    log_info "清除pid: $mypid"
    do_it kill -9 $mypid
    do_it rm "$PID_FILE"
  else
    log_info "killall -u ${USER} -9 java"
    do_it killall -u ${USER} -9 java
  fi
  log_info "清理java服务成功"

  # 清理docker
  log_info "清理docker服务"
  sudo docker ps -a | awk 'NR != 1{print $(NF)}' | grep ${APP_NAME}-${ENV_TYPE}

  if [ $? -eq 0 ]; then
    do_it sudo docker rm -f ${APP_NAME}-${ENV_TYPE}
  else
    log_info "未发现该应用正在运行docker服务"
  fi

  # 清理nginx
  log_info "开始清理nginx"
  pidofproc nginx
  if [ $? -eq 0 ]; then
    # 查看是否有该应用程序配置
    ls ${NGINX_CONFIG_DIR} | grep -w ${NGINX_CONF}
    if [ $? -eq 0 ]; then
      log_info "发现该应用nginx配置文件:${NGINX_CONF}"
      do_it rm -f ${NGINX_CONFIG_DIR}/${NGINX_CONF}
      do_it sudo ${NGINX_SBIN_PATH} -s reload
      log_info "清理完成，并已重启nginx"
    else
      log_info "未发现该应用程序的nginx配置文件"
    fi
  else
    log_info "未发现nginx服务正在运行"
  fi
}

# 删除工作区的文件除了传入的文件名
rm_except() {
  cd ${WORK_DIR}
  local all_files=$(ls)
  local except_files="$@"
  log_info "清除目录$WORK_DIR,除了文件:$except_files"
  for file in $all_files; do
    local del=true
    for except_file in $except_files; do
      if [[ "$file" == "$except_file" ]]; then
        del=false
        break
      fi
    done
    [ $del = true ] && do_it rm -rf $file
  done
}

# 删除工作区文件
clean_work_dir() {
  log_info "starting clear $WORK_DIR"
  # 杀掉上一次的部署
  if [ "$NEED_RESTORE" == "yes" ]; then
    rm_except "env_script env_script.zip $RESTORE_FILE logs"
  else
    rm_except "env_script env_script.zip logs"
  fi
}

# 清理环境
clean_env() {
  log_info "开始清理环境"
  kill_ws
  clean_work_dir
}

# 检查部署状态
check_deploy_status() {
  if [ "$DEPLOY_TYPE" == "docker" ]; then
    # 获取docker部署状态
    local docker_status=$(sudo docker inspect -f '{{.State.Running}}' ${APP_NAME}-${ENV_TYPE})
    [ ! $? -eq 0 ] && project_log_error_exit "容器运行状态异常，部署失败"
  elif [ "$DEPLOY_TYPE" == "nginx" ]; then
    do_it netstat -anop | grep -w "LISTEN" | grep -w ${PORT}
    [ $? -eq 0 ] && log_info "nginx监听正常" || project_log_error_exit "应用部署失败"
  else
    checkPIDfile
    [ ! $? -eq 0 ] && project_log_error_exit "deploy failed for pidFile is empty"
  fi
  check_url
}

# 检查url是否可以访问
check_url() {
  if [ "$CHECK_URL"x == ""x ]; then
    log_info "无check_url，跳过url检测"
    return
  fi
  log_info "starting check with url: ${CHECK_URL}"

  local check_url=$CHECK_URL
  log_info "Starting check $APP_NAME with url: $check_url"
  local count=0
  local max_check_num=3

  while true; do
    ((count++))
    if [[ $count -gt ${max_check_num} ]]; then
      local error_logs=$(get_app_log)
      project_log_error_exit "$(cat error_logs) \nFailed to check app with url: $check_url.\n "
    fi
    log_info "try $count times"
    local resp_code=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 -m 5 $check_url)
    [[ "$resp_code" == "200" ]] && break
    sleep 3
  done

  log_info "$check_url return 200"
}

# 获取应用日志
get_app_log() {
  log_info "获取应用服务最新日志"
  if [[ "$DEPLOY_TYPE" =~ (jar|nginx) ]]; then
    tail -${LOG_LINE_NUM} ${APP_LOG}
  elif [ "$DEPLOY_TYPE" == "docker" ]; then
    sudo docker logs --tail ${LOG_LINE_NUM} ${APP_NAME}-${ENV_TYPE}
  elif [ "$DEPLOY_TYPE" == "war" ]; then
    tail -${LOG_LINE_NUM} ${TOMCAT_LOG}
  else
    log_error "获取日志失败"
  fi
}

# 部署war包
deploy_war() {

  local deploy_package=$1
  log_info "开始获取${TOMCAT_VERSION}.zip"
  wget -P ${HOEM} -nv ${TOMCAT_DOWNLOAD_URL}

  if [ ! $? -eq 0 ]; then
    log_warning "下载失败，开始拷贝${TOMCAT_PATH}/${TOMCAT_VERSION}"
    cp ${TOMCAT_PATH}/${TOMCAT_VERSION}.zip ${HOME}
    [ ! $? -eq 0 ] && project_log_error_exit "获取${TOMCAT_VERSION}失败"
  fi
  log_info "获取${TOMCAT_VERSION}成功"
  unzip ${HOME}/${TOMCAT_VERSION}.zip

  log_info "Starting deploy $deploy_package"
  #PORT1/2/3是tomcat的其他端口
  MINUS=$(expr 8080 - $PORT)
  PORT1=$(expr 8443 - $MINUS)
  PORT2=$(expr 8009 - $MINUS + 20)
  PORT3=$(expr 8005 - $MINUS + 20)

  # 修改tomcat配置文件
  log_info "修改tomcat配置：PORT:${PORT}"
  cd $TOMCAT_HOME/conf
  sed -i "s/8080/$PORT/g" server.xml
  sed -i "s/8443/$PORT1/g" server.xml
  sed -i "s/8009/$PORT2/g" server.xml
  sed -i "s/8005/$PORT3/g" server.xml

  # 设置查找该pid的命令
  PID_FIND_STR="${TOMCAT_VERSION}"
  log_info "启动tomcat"
  cd $TOMCAT_HOME/bin

  chmod 755 *.sh
  sh startup.sh
  sleep 3
  return
}

# 部署jar包
deploy_jar() {
  local deploy_package=$1
  log_info "Starting deploy $deploy_package"
  PID_FIND_STR="java -jar $deploy_package"

  log_info "nohup java -jar  $deploy_package > ${APP_LOG} 2>&1 &"
  nohup java -jar $deploy_package >${APP_LOG} 2>&1 &
}

# 部署.tar.gz包
deploy_tgz() {
  local deploy_package=$1
  log_info "Starting deploy ${deploy_package}"

  # 生成nginx配置文件，根据ENV_TYPE.APP_NAME.com作为域名 NGINX_HTML_DIR/APP_NAME作为root
  log_info "generate nginx config"
  eval "cat <<EOF 
  $(<$NGINX_TEMPLATE) 
  EOF "
  >${NGINX_CONFIG_DIR}/$NGINX_CONF

  [ ! $? -eq 0 ] && project_log_error_exit "配置文件生成失败，请查看是否拥有${NGINX_CONFIG_DIR}写入权限"

  # 部署目录
  # deploy_dir=${NGINX_HOME}/html/${APP_NAME}/
  # log_info "清理部署目录: ${deploy_dir}"
  # [ -d ${deploy_dir} ] && rm -rf ${deploy_dir}
  # tar -xvf ${deploy_package} -C  ${deploy_dir} > /dev/null 2>&1

  log_info "解压部署包${deploy_package}到${HOME}"
  tar -xvf ${deploy_package} -C ${HOME}

  # 重启nginx server
  log_info "Restart nginx"
  eval "sudo ${NGINX_SBIN_PATH} -s reload"
}

# 部署docker容器
deploy_docker() {
  local imageName=$1
  log_info "Starting deploy $imageName"
  # 部署容器时，需要获取容器中的端口，进行映射，此项可以在配置项中配置
  # 默认为暴漏的端口
  CONTAINER_PORT=${container_port:-${PORT}}
  log_info "PORT:${PORT},CONTAINER_PORT:${CONTAINER_PORT}"
  # 判断是否已经部署
  sudo docker ps -a | awk 'NR != 1{print $(NF)}' | grep ${APP_NAME}-${ENV_TYPE}
  [ $? -eq 0 ] && do_it sudo docker rm -f ${APP_NAME}-${ENV_TYPE}
  # 部署的容器名称为应用名-项目名
  do_it sudo docker run -d --name ${APP_NAME}-${ENV_TYPE} -p ${PORT}:${CONTAINER_PORT} $imageName

}

# 开始部署
start_env() {

  # 加载配置项作为全局变量
  war_Suffix=".war"
  jar_Suffix=".jar"
  tar_gz_Suffix=".tar.gz"
  zip_Suffix=".zip"

  # 获取构建包名
  deploy_package=$(echo ${TAR_ADDRESS##*/})

  # 加载配置作为全局变量
  log_info "加载配置项:\n $(<$ENV_PROPERTIES_FILE)" && source $ENV_PROPERTIES_FILE

  # 如果部署包为docker镜像(判断是否包含":"")，则使用root权限部署
  if [[ $deploy_package =~ .+:.+ ]]; then
    DEPLOY_TYPE=docker
    imageName=$TAR_ADDRESS
    deploy_docker $imageName
  else
    # 下载部署包,-nv非详细输出
    log_info "下载部署包: $TAR_ADDRESS"
    wget -nv http://package.switch.aliyun.com:8088/$TAR_ADDRESS

    # 下载失败则退出
    [ $? -eq 1 ] && project_log_error_exit "下载失败"

    # 根据包名匹配对应的部署脚本
    if [[ ${deploy_package} =~ $war_Suffix ]]; then
      DEPLOY_TYPE=war
      deploy_war ${deploy_package}

    elif [[ ${deploy_package} =~ $jar_Suffix ]]; then
      DEPLOY_TYPE=jar
      deploy_jar ${deploy_package}

    elif [[ ${deploy_package} =~ $tar_gz_Suffix ]]; then
      DEPLOY_TYPE=nginx
      deploy_tgz ${deploy_package}
    else
      project_log_error_exit "没有此构建包的部署方式"
    fi
  fi
  # 部署完成后等待5s继续执行
  sleep 5
  log_info "部署${deploy_package}完成"
}

# 更新部署脚本
update_env_script() {
  cd ${HOME}
  log_info "starting update env_script"
  log_info "clearing env_script"
  do_it rm -rf env_script

  # 下载到指定目录
  log_info "Try download env_script"
  wget -nv -O ${ENV_SCRIPT} ${ENV_SCRIPT_URL}
  local download=$?
  if [ ! $download -eq 0 ]; then
    log_warning "下载失败，尝试拷贝/root/env_script.zip"
    sudo cp -f /root/env_script.zip $HOME
    if [ $? -eq 0 ]; then
      log_info "拷贝成功，开始解压$ENV_SCRIPT_PATH"
      do_it unzip -o env_script.zip
    else
      log_info "拷贝失败"
    fi
  else
    do_it unzip -o env_script.zip
  fi

  # 解压并赋权
  log_info "unzip env_script successful"
  do_it chown -R ${USER}:${USER} /home/${USER}
  log_info "update env_script done"
}
